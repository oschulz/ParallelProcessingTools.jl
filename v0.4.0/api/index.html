<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · ParallelProcessingTools</title><link rel="canonical" href="https://oschulz.github.io/ParallelProcessingTools.jl/stable/api/index.html"/><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>ParallelProcessingTools</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li class="current"><a class="toctext" href>API</a><ul class="internal"><li><a class="toctext" href="#Types-1">Types</a></li><li><a class="toctext" href="#Functions-and-macros-1">Functions and macros</a></li><li class="toplevel"><a class="toctext" href="#Documentation-1">Documentation</a></li></ul></li><li><a class="toctext" href="../LICENSE/">LICENSE</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>API</a></li></ul><a class="edit-page" href="https://github.com/oschulz/ParallelProcessingTools.jl/blob/master/docs/src/api.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>API</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="API-1" href="#API-1">API</a></h1><h2><a class="nav-anchor" id="Types-1" href="#Types-1">Types</a></h2><ul><li><a href="#ParallelProcessingTools.AbstractThreadLocal"><code>ParallelProcessingTools.AbstractThreadLocal</code></a></li><li><a href="#ParallelProcessingTools.ThreadLocal"><code>ParallelProcessingTools.ThreadLocal</code></a></li></ul><h2><a class="nav-anchor" id="Functions-and-macros-1" href="#Functions-and-macros-1">Functions and macros</a></h2><ul><li><a href="#ParallelProcessingTools.@critical-Tuple{Any}"><code>ParallelProcessingTools.@critical</code></a></li><li><a href="#ParallelProcessingTools.@mp_async-Tuple{Any}"><code>ParallelProcessingTools.@mp_async</code></a></li><li><a href="#ParallelProcessingTools.@mt_async-Tuple{Any}"><code>ParallelProcessingTools.@mt_async</code></a></li><li><a href="#ParallelProcessingTools.@onprocs-Tuple{Any,Any}"><code>ParallelProcessingTools.@onprocs</code></a></li><li><a href="#ParallelProcessingTools.@onthreads-Tuple{Any,Any}"><code>ParallelProcessingTools.@onthreads</code></a></li><li><a href="#ParallelProcessingTools.allthreads-Tuple{}"><code>ParallelProcessingTools.allthreads</code></a></li><li><a href="#ParallelProcessingTools.getallvalues"><code>ParallelProcessingTools.getallvalues</code></a></li><li><a href="#ParallelProcessingTools.getlocalvalue"><code>ParallelProcessingTools.getlocalvalue</code></a></li><li><a href="#ParallelProcessingTools.workpart"><code>ParallelProcessingTools.workpart</code></a></li></ul><h1><a class="nav-anchor" id="Documentation-1" href="#Documentation-1">Documentation</a></h1><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ParallelProcessingTools.AbstractThreadLocal" href="#ParallelProcessingTools.AbstractThreadLocal"><code>ParallelProcessingTools.AbstractThreadLocal</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">abstract type AbstractThreadLocal{T} end</code></pre><p>Abstract type for thread-local values of type <code>T</code>.</p><p>The value for the current thread is accessed via <code>getindex(::AbstractThreadLocal)</code> and `setindex(::AbstractThreadLocal, x).</p><p>To access both regular and thread-local values in a unified manner, use the function <a href="#ParallelProcessingTools.getlocalvalue"><code>getlocalvalue</code></a>.</p><p>To get the all values across all threads, use the function <a href="#ParallelProcessingTools.getallvalues"><code>getallvalues</code></a>.</p><p>Default implementation is <a href="#ParallelProcessingTools.ThreadLocal"><code>ThreadLocal</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/oschulz/ParallelProcessingTools.jl/blob/ddb50c5d1f794ae3e8b96858e0fd8d1017317e89/src/threadlocal.jl#L4-L19">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ParallelProcessingTools.ThreadLocal" href="#ParallelProcessingTools.ThreadLocal"><code>ParallelProcessingTools.ThreadLocal</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">ThreadLocal{T} &lt;: AbstractThreadLocal{T}</code></pre><p>Represents a thread-local value. See <a href="#ParallelProcessingTools.AbstractThreadLocal"><code>AbstractThreadLocal</code></a> for the API.</p><p>Constructors:</p><pre><code class="language-julia">ThreadLocal{T}() where {T}
ThreadLocal(value::T) where {T}
ThreadLocal{T}(f::Base.Callable) where {T}</code></pre><p>Examples:</p><pre><code class="language-julia">tlvalue = ThreadLocal(0)
@onthreads allthreads() tlvalue[] = Base.Threads.threadid()
getallvalues(tlvalue) == allthreads()</code></pre><pre><code class="language-julia">rand_value_on_each_thread = ThreadLocal{Float64}(rand)
all(x -&gt; 0 &lt; x &lt; 1, getallvalues(rand_value_on_each_thread))</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/oschulz/ParallelProcessingTools.jl/blob/ddb50c5d1f794ae3e8b96858e0fd8d1017317e89/src/threadlocal.jl#L54-L80">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ParallelProcessingTools.@critical-Tuple{Any}" href="#ParallelProcessingTools.@critical-Tuple{Any}"><code>ParallelProcessingTools.@critical</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-julia">@critical expr</code></pre><p>Mark code in <code>expr</code> as a critical section. Code in critical sections will never be executed in parallel (via multithreading) to any other critical section.</p><p><code>@critical</code> is very useful to mark non-threadsafe code.</p><p>Example:</p><pre><code class="language-julia">@onthreads allthreads() begin
    @critical @info Base.Threads.threadid()
end

Without `@critical`, the above will typically crash Julia.</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/oschulz/ParallelProcessingTools.jl/blob/ddb50c5d1f794ae3e8b96858e0fd8d1017317e89/src/threadsafe.jl#L100-L118">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ParallelProcessingTools.@mp_async-Tuple{Any}" href="#ParallelProcessingTools.@mp_async-Tuple{Any}"><code>ParallelProcessingTools.@mp_async</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-julia">@mp_async expr</code></pre><p>Run <code>expr</code> asynchronously on a worker process.</p><p>Compatible with <code>@sync</code>.</p><p>Equivalent to <code>Distributed.@spawn expr</code> on Julia &lt;= v1.2, equivalent to <code>Distributed.@spawn :any expr</code> on Julia &gt;= v1.3.</p></div></div><a class="source-link" target="_blank" href="https://github.com/oschulz/ParallelProcessingTools.jl/blob/ddb50c5d1f794ae3e8b96858e0fd8d1017317e89/src/onprocs.jl#L36-L45">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ParallelProcessingTools.@mt_async-Tuple{Any}" href="#ParallelProcessingTools.@mt_async-Tuple{Any}"><code>ParallelProcessingTools.@mt_async</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-julia">@mt_async expr</code></pre><p>Spawn a Julia task running <code>expr</code> asynchronously.</p><p>Compatible with <code>@sync</code>. Uses a multi-threaded task scheduler if available (on Julia &gt;= v1.3).</p><p>Equivalent to <code>Base.@async</code> on Julia &lt;= v1.2, equivalent to <code>Base.Threads.@spawn</code> on Julia &gt;= v1.3.</p></div></div><a class="source-link" target="_blank" href="https://github.com/oschulz/ParallelProcessingTools.jl/blob/ddb50c5d1f794ae3e8b96858e0fd8d1017317e89/src/onthreads.jl#L198-L208">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ParallelProcessingTools.@onprocs-Tuple{Any,Any}" href="#ParallelProcessingTools.@onprocs-Tuple{Any,Any}"><code>ParallelProcessingTools.@onprocs</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-julia">@onprocs procsel expr</code></pre><p>Executes <code>expr</code> in parallel on all processes in <code>procsel</code>. Waits until all processes are done. Returns all results as a vector (or as a single scalar value, if <code>procsel</code> itself is a scalar).</p><p>Example:</p><pre><code class="language-julia">using Distributed
addprocs(2)
workers() == @onprocs workers() myid()</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/oschulz/ParallelProcessingTools.jl/blob/ddb50c5d1f794ae3e8b96858e0fd8d1017317e89/src/onprocs.jl#L10-L24">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ParallelProcessingTools.@onthreads-Tuple{Any,Any}" href="#ParallelProcessingTools.@onthreads-Tuple{Any,Any}"><code>ParallelProcessingTools.@onthreads</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-julia">@onthreads threadsel expr</code></pre><p>Execute code in <code>expr</code> in parallel on the threads in <code>threadsel</code>.</p><p><code>threadsel</code> should be a single thread-ID or a range (or array) of thread-ids. If <code>threadsel == Base.Threads.threadid()</code>, <code>expr</code> is run on the current tread with only minimal overhead.</p><p>Note: Currently, multiple <code>@onthreads</code> sections will not run in parallel to each other, even if they use disjunct sets of threads, due to limitations of the Julia multithreading implementation. This restriction is likely to disappear in future Julia versions.</p><p>In contrast to <code>Base.Threads.@threads</code>, <code>@onthreads</code> does forward exceptions to the caller.</p><p>Example 1:</p><pre><code class="language-juliaexpr">tlsum = ThreadLocal(0.0)
data = rand(100)
@onthreads allthreads() begin
    tlsum[] = sum(workpart(data, allthreads(), Base.Threads.threadid()))
end
sum(getallvalues(tlsum)) ≈ sum(data)</code></pre><p>Example 2:</p><pre><code class="language-julia"># Assuming 4 threads:
tl = ThreadLocal(42)
threadsel = 2:3
@onthreads threadsel begin
    tl[] = Base.Threads.threadid()
end
getallvalues(tl)[threadsel] == [2, 3]
getallvalues(tl)[[1,4]] == [42, 42]</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/oschulz/ParallelProcessingTools.jl/blob/ddb50c5d1f794ae3e8b96858e0fd8d1017317e89/src/onthreads.jl#L134-L174">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ParallelProcessingTools.allthreads-Tuple{}" href="#ParallelProcessingTools.allthreads-Tuple{}"><code>ParallelProcessingTools.allthreads</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">allthreads()</code></pre><p>Convencience function, returns <code>1:Base.Threads.nthreads()</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/oschulz/ParallelProcessingTools.jl/blob/ddb50c5d1f794ae3e8b96858e0fd8d1017317e89/src/onthreads.jl#L125-L129">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ParallelProcessingTools.getallvalues" href="#ParallelProcessingTools.getallvalues"><code>ParallelProcessingTools.getallvalues</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">getallvalues(v::AbstractThreadLocal{T})::AbstractVector{T}</code></pre><p>Access the all values (one for each thread) of a thread-local value as a vector. Can only be called in single-threaded code sections.</p></div></div><a class="source-link" target="_blank" href="https://github.com/oschulz/ParallelProcessingTools.jl/blob/ddb50c5d1f794ae3e8b96858e0fd8d1017317e89/src/threadlocal.jl#L37-L42">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ParallelProcessingTools.getlocalvalue" href="#ParallelProcessingTools.getlocalvalue"><code>ParallelProcessingTools.getlocalvalue</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">getlocalvalue(x::Any) = x
getlocalvalue(x::ThreadLocal) = x[]</code></pre><p>Access plain values and thread-local values in a unified fashion.</p></div></div><a class="source-link" target="_blank" href="https://github.com/oschulz/ParallelProcessingTools.jl/blob/ddb50c5d1f794ae3e8b96858e0fd8d1017317e89/src/threadlocal.jl#L27-L32">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ParallelProcessingTools.workpart" href="#ParallelProcessingTools.workpart"><code>ParallelProcessingTools.workpart</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">workpart(data::AbstractArray, workersel::AbstractVector{W}, current_worker::W) where {W}</code></pre><p>Get the part of <code>data</code> that the execution unit <code>current_worker</code> is responsible for. Implies a partition of <code>data</code> across the workers listed in <code>workersel</code>.</p><p>For generic <code>data</code> arrays, <code>workpart</code> will return a view. If <code>data</code> is a <code>Range</code> (e.g. indices to be processed), a sub-range will be returned.</p><p>Type <code>W</code> will typically be <code>Int</code> and <code>workersel</code> will usually be a range/array of thread/process IDs.</p><p>Note: <code>workersel</code> is required to be sorted in ascending order and to contain no duplicate entries.</p><p>Examples:</p><pre><code class="language-julia">using Distributed, Base.Threads
A = rand(100)
# ...
sub_A = workpart(A, workers(), myid())
# ...
idxs = workpart(eachindex(sub_A), allthreads(), threadid())
for i in idxs
    # ...
end</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/oschulz/ParallelProcessingTools.jl/blob/ddb50c5d1f794ae3e8b96858e0fd8d1017317e89/src/workpartition.jl#L62-L91">source</a></section><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Home</span></a><a class="next" href="../LICENSE/"><span class="direction">Next</span><span class="title">LICENSE</span></a></footer></article></body></html>
