<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · ParallelProcessingTools</title><link rel="canonical" href="https://oschulz.github.io/ParallelProcessingTools.jl/stable/index.html"/><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>ParallelProcessingTools</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>Home</a><ul class="internal"><li><a class="toctext" href="#Work-partitions-1">Work partitions</a></li><li><a class="toctext" href="#Thread-safety-1">Thread-safety</a></li><li><a class="toctext" href="#Thread-local-variables-1">Thread-local variables</a></li><li><a class="toctext" href="#Multithreaded-code-execution-1">Multithreaded code execution</a></li><li><a class="toctext" href="#Multiprocess-code-execution-1">Multiprocess code execution</a></li><li><a class="toctext" href="#Creating-multithreaded-workers-1">Creating multithreaded workers</a></li></ul></li><li><a class="toctext" href="api/">API</a></li><li><a class="toctext" href="LICENSE/">LICENSE</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Home</a></li></ul><a class="edit-page" href="https://github.com/oschulz/ParallelProcessingTools.jl/blob/master/docs/src/index.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Home</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="ParallelProcessingTools.jl-1" href="#ParallelProcessingTools.jl-1">ParallelProcessingTools.jl</a></h1><p>This Julia package provides some tools to ease multithreaded and distributed programming, especially for more complex use cases and when using multiple processes with multiple threads on each process.</p><p>This package follows the SPMD (Single Program Multiple Data) paradigm (like, e.g MPI, Cuda, OpenCL and <code>DistributedArrays.SPMD</code>): Run the same code on every execution unit (process or thread) and make the code responsible for figuring out which part of the data it should process. This differs from the approach of <code>Base.Threads.@threads</code> and <code>Distributed.@distributed</code>. SPMD is more appropriate for complex cases that the latter do not handle well (e.g. because some initial setup is required on each execution unit and/or iteration scheme over the data is more complex, control over SIMD processing is required, etc.).</p><p>This package also implements thread-local variables and tooling to handle non-thread-safe code.</p><p>In addition, <code>ParallelProcessingTools</code> provides functions and macros designed to ease the transition to the new multi-threading model introduced in Julia v1.3.</p><p>Note: Some features may not work on Windows, currently.</p><h2><a class="nav-anchor" id="Work-partitions-1" href="#Work-partitions-1">Work partitions</a></h2><p><code>workpart</code> partitions an <code>AbstractArray</code> across a a specified set of workers (i.e. processes or threads). E.g.</p><pre><code class="language-julia">A = rand(100)
workpart(A, 4:7, 5) == view(A, 26:50)</code></pre><p>returns a views into the array that worker <code>5</code> out of a set or workers <code>4:7</code> will be responsible for. The intended usage is</p><pre><code class="language-julia">using Distributed
@everywhere using Base.Threads, ParallelProcessingTools
@everywhere data = rand(1000)
@everywhere procsel = workers()
@onprocs procsel begin
    sub_A = workpart(data, procsel, myid())
    threadsel = allthreads()
    @onthreads threadsel begin
        # ... some initialization, create local buffers, etc.
        idxs = workpart(eachindex(sub_A), threadsel, threadid())
        for i in idxs
            # ... A[i] ...
        end
    end
end</code></pre><p>see below for a full example.</p><p>If <code>data</code> is a <code>DistributedArrays.DArray</code>, then <code>DistributedArrays.localpart(data)</code> should be used instead of <code>workpart(data, workers(), myid())</code>.</p><h2><a class="nav-anchor" id="Thread-safety-1" href="#Thread-safety-1">Thread-safety</a></h2><p>Use <code>@critical</code> to mark non thread-safe code, e.g. for logging. For example</p><pre><code class="language-julia">@onthreads allthreads() begin
    @critical @info Base.Threads.threadid()
end</code></pre><p>would crash Julia without <code>@critical</code> because <code>@info</code> is not thread-safe.</p><p>Note: This doesn&#39;t always work for multithreaded code on other processes yet.</p><h2><a class="nav-anchor" id="Thread-local-variables-1" href="#Thread-local-variables-1">Thread-local variables</a></h2><p>Thread-local variable can be created and initialized via</p><pre><code class="language-julia">tl = ThreadLocal(0.0)</code></pre><p>The API is the similar to <code>Ref</code>: <code>tl[]</code> gets the value of <code>tl</code> for the current thread, <code>tl[] = 4.2</code> sets the value for the current thread. <code>getallvalues(tl)</code> returns the values for all threads as a vector, and can only be called from single-threaded code.</p><h2><a class="nav-anchor" id="Multithreaded-code-execution-1" href="#Multithreaded-code-execution-1">Multithreaded code execution</a></h2><p>The macro <code>@onthreads threadsel expr</code> will run the code in <code>expr</code> on the threads in <code>threadsel</code> (typically a range of thread IDs). For convenience, the package exports <code>allthreads() = 1:nthreads()</code>. Here&#39;s a simple example on how to use thread-local variables and <code>@onthreads</code> to sum up numbers in parallel:</p><pre><code class="language-julia">tlsum = ThreadLocal(0.0)
data = rand(100)
@onthreads allthreads() begin
    tlsum[] = sum(workpart(data, allthreads(), Base.Threads.threadid()))
end
sum(getallvalues(tlsum)) ≈ sum(data)</code></pre><p><code>@onthreads</code> forwards exceptions thrown by the code in <code>expr</code> to the caller (in contrast to, <code>Base.Threads.@threads</code>, that will currently print an exception but not forward it, so when using <code>@threads</code> program execution simply continues after a failure in multithreaded code).</p><p>Note: Julia can currently run only one function on multiple threads at the same time (this restriction is likely to disappear in the the future). So even if <code>threadsel</code> does not include all threads, the rest of the threads will be idle but blocked and cannot be used to run other code in parallel. However, the ability to run on a subset of the available threads is still useful to measure the scaling behavior of multithreaded code (without restarting Julia with a different value for <code>$JULIA_NUM_THREADS</code>).</p><h2><a class="nav-anchor" id="Multiprocess-code-execution-1" href="#Multiprocess-code-execution-1">Multiprocess code execution</a></h2><p>The macro <code>@onprocs procsel expr</code> will run the code in <code>expr</code> on the processes in <code>procsel</code> (typically an array of process IDs). <code>@onprocs</code> returns a vector with the result of <code>expr</code> on each process and will wait until all the results are available (but may of course be wrapped in <code>@async</code>). A simple example to get the process ID on each worker process:</p><pre><code class="language-julia">using Distributed
addprocs(2)
workers() == @onprocs workers() myid()</code></pre><p>Note: If the data can be expressed in terms of a <code>DistributedArrays.DArray</code>, it may be more appropriate and convenient to use the multiprocess execution tooling available in the package <code>DistributedArrays</code> (possibly combined with <code>ParallelProcessingTools.@onthreads</code>).</p><h2><a class="nav-anchor" id="Creating-multithreaded-workers-1" href="#Creating-multithreaded-workers-1">Creating multithreaded workers</a></h2><p>Julia currently doesn&#39;t provide an easy way to start multithreaded remote worker instances. <code>ParallelProcessingTools</code> provides a script <code>mtjulia.sh</code> (currently Linux-only) that will start Julia with <code>$JULIA_NUM_THREADS</code> set to a suitable value for each worker host (currently the number of physical processes on one NUMA node). <code>mtjulia_exe()</code> will return the absolute path to <code>mtjulia.sh</code>. So multithreaded workers can be spawned (via SSH) like this:</p><pre><code class="language-julia">addprocs([hostname1, ...], exename = mtjulia_exe())</code></pre><h3><a class="nav-anchor" id="Example-use-case:-1" href="#Example-use-case:-1">Example use case:</a></h3><p>As a simple real-world use case, let&#39;s histogram distributed data on multiple processes and threads:</p><p>Set up a cluster of multithreaded workers and load the required packages:</p><pre><code class="language-julia">using Distributed, ParallelProcessingTools
addprocs([&quot;hostname1&quot;, ...], exename = mtjulia_exe())
@everywhere using ParallelProcessingTools, Base.Threads,
    DistributedArrays, Statistics, StatsBase</code></pre><p>Create some distributed data and check how the data is distributed:</p><pre><code class="language-julia">data = drandn(10^8)
procsel = procs(data)
@onprocs procsel size(localpart(data))</code></pre><p>Check the number of threads on each worker holding a part of the data:</p><pre><code class="language-julia">@onprocs procsel nthreads()</code></pre><p>Create histograms in parallel on all threads of all workers and merge:</p><pre><code class="language-julia">proc_hists = @onprocs procsel begin
    local_data = localpart(data)
    tl_hist = ThreadLocal(Histogram((-6:0.1:6,), :left))
    @onthreads allthreads() begin
        data_for_this_thread = workpart(local_data, allthreads(), threadid())
        append!(tl_hist[], data_for_this_thread)
    end
    merged_hist = merge(getallvalues(tl_hist)...)
end
final_hist = merge(proc_hists...)</code></pre><p>Check result:</p><pre><code class="language-none">sum(final_hist.weights) ≈ length(data)

using Plots
plot(final_hist)</code></pre><p>Note: This example is meant to show how to combine the features of this package. The multi-process part of this particular use case can be written in a simpler way using functionality from <code>DistributedArrays</code>.</p><footer><hr/><a class="next" href="api/"><span class="direction">Next</span><span class="title">API</span></a></footer></article></body></html>
